name: bbx Saga Test Suite (Public Release)

on:
  workflow_run:
    workflows: ["Private Build (Draft Binaries)"]
    types: [completed]
  workflow_dispatch:

concurrency:
  group: ${{ github.repository }}-bbx-saga
  cancel-in-progress: true

permissions:
  contents: read      # Required for actions/checkout
  actions: read       # Required for 'gh run view' to inspect the upstream workflow inputs

env:
  PRIVATE_TAG: false
  USE_PRIVATE_RELEASE: false
  TARGET_RELEASE_REPO: "BrowserBox/BrowserBox"

jobs:
  build:
    if: github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success'
    continue-on-error: ${{ matrix.os == 'windows-latest' }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        container_image:
          - '' # No container (native runner)
          - 'dokken/centos-stream-10'
          - 'debian:latest'
        exclude:
          - os: macos-latest
            container_image: 'dokken/centos-stream-10'
          - os: macos-latest
            container_image: 'debian:latest'
          - os: windows-latest
            container_image: 'dokken/centos-stream-10'
          - os: windows-latest
            container_image: 'debian:latest'
    runs-on: ${{ matrix.os }}
    timeout-minutes: 10
    container: ${{ matrix.container_image }}
    steps:
      # 1. Try to download the artifact (Solution 3), but DON'T fail if missing
      - name: Download Tag Artifact
        if: github.event_name == 'workflow_run'
        uses: actions/download-artifact@v4
        with:
          name: workflow-inputs
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true  # <--- CRITICAL ADDITION

      # 2. The Ultimate Logic Block (Artifact -> CLI -> Regex)
      - name: Derive PRIVATE_TAG
        if: github.event_name == 'workflow_run'
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          tag=""
          
          # ATTEMPT 1: Check for Artifact (Solution 3)
          if [[ -f "workflow_tag.txt" ]]; then
            tag=$(cat workflow_tag.txt | tr -d '[:space:]')
            echo "✓ Found tag via Artifact: $tag"
          fi

          # ATTEMPT 2: Check via GH CLI (Solution 2)
          if [[ -z "$tag" ]]; then
            echo "Artifact missing. Attempting gh CLI..."
            workflow_run_id="${{ github.event.workflow_run.id }}"
            tag=$(gh run view "$workflow_run_id" --repo "${{ github.repository }}" --json inputs --jq '.inputs.tag // empty' 2>/dev/null || echo "")
            if [[ -n "$tag" ]]; then
              echo "✓ Found tag via gh CLI: $tag"
            fi
          fi

          # ATTEMPT 3: Check via Run Title Regex (Solution 1)
          if [[ -z "$tag" ]]; then
            echo "CLI failed. Attempting display_title extraction..."
            display_title="${{ github.event.workflow_run.display_title }}"
            # Matches "Private Build v1.2.3" or just "v1.2.3"
            if [[ "$display_title" =~ (v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?) ]]; then
              tag="${BASH_REMATCH[1]}"
              echo "✓ Found tag via Display Title: $tag"
            fi
          fi

          # FINAL CHECK
          if [[ -z "$tag" ]]; then
            echo "::error::Could not resolve PRIVATE_TAG from Artifact, CLI, or Title."
            exit 1
          fi

          # EXPORT
          {
            echo "PRIVATE_TAG=$tag"
            echo "USE_PRIVATE_RELEASE=true"
            echo "TARGET_RELEASE_REPO=BrowserBox/BrowserBox"
          } >> "$GITHUB_ENV"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check if actor is repository owner or me
        shell: bash
        run: |
          if [[ "${{ github.actor }}" != "crisdosaygo" ]]; then
            echo "Actor is not me. Not running CI"
            exit 1
          fi

      - name: Prepare test script (Unix/macOS)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: chmod +x tests/test-bbx.sh

      - name: Install BrowserBox via binary (Unix/macOS)
        if: matrix.os != 'windows-latest'
        shell: bash
        env:
          BBX_INSTALL_USER: "bbxuser"
          BBX_TEST_AGREEMENT: "true"
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BBX_HOSTNAME: "localhost"
          BB_QUICK_EXIT: "yesplease"
          EMAIL: "test@example.com"
          LICENSE_KEY: ${{ secrets.BB_LICENSE_KEY }}
          STATUS_MODE: ${{ secrets.STATUS_MODE_KEY }}
          INSTALL_DOC_VIEWER: "false"
          TARGET_RELEASE_REPO: ${{ env.TARGET_RELEASE_REPO }}
          PRIVATE_TAG: ${{ env.PRIVATE_TAG }}
        run: |
          if [[ "${USE_PRIVATE_RELEASE}" == "true" ]]; then
            if [[ -z "${PRIVATE_TAG}" ]]; then
              echo "PRIVATE_RELEASE_TAG is required when use_private_release=true" >&2
              exit 1
            fi
            export BBX_RELEASE_REPO="${TARGET_RELEASE_REPO}"
            export BBX_RELEASE_TAG="${PRIVATE_TAG}"
            echo "Using private release ${BBX_RELEASE_REPO}@${BBX_RELEASE_TAG}"
          fi
          chmod +x ./bbx.sh
          ./bbx.sh install

      - name: Execute BBX Test Saga (Unix/macOS)
        if: matrix.os != 'windows-latest'
        shell: bash
        env:
          BBX_INSTALL_USER: "bbxuser"
          BBX_HOSTNAME: "localhost"
          BB_QUICK_EXIT: "yesplease"
          EMAIL: "test@example.com"
          LICENSE_KEY: ${{ secrets.BB_LICENSE_KEY }}
          BBX_TEST_AGREEMENT: "true"
          STATUS_MODE: ${{ secrets.STATUS_MODE_KEY }}
          INSTALL_DOC_VIEWER: "false"
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TARGET_RELEASE_REPO: ${{ env.TARGET_RELEASE_REPO }}
          PRIVATE_TAG: ${{ env.PRIVATE_TAG }}
        run: |
          [ -z "$BBX_HOSTNAME" ] && echo "BBX_HOSTNAME is not set" || echo "BBX_HOSTNAME is set"
          [ -z "$EMAIL" ] && echo "EMAIL is not set" || echo "EMAIL is set"
          [ -z "$LICENSE_KEY" ] && echo "LICENSE_KEY is not set" || echo "LICENSE_KEY is set"
          [ -z "$BBX_TEST_AGREEMENT" ] && echo "BBX_TEST_AGREEMENT is not set" || echo "BBX_TEST_AGREEMENT is set"
          [ -z "$STATUS_MODE" ] && echo "STATUS_MODE is not set" || echo "STATUS_MODE is set"
          [ -z "$INSTALL_DOC_VIEWER" ] && echo "INSTALL_DOC_VIEWER is not set" || echo "INSTALL_DOC_VIEWER is set to $INSTALL_DOC_VIEWER"
          if [[ "${USE_PRIVATE_RELEASE}" == "true" ]]; then
            if [[ -z "${PRIVATE_TAG}" ]]; then
              echo "PRIVATE_RELEASE_TAG is required when use_private_release=true" >&2
              exit 1
            fi
            export BBX_RELEASE_REPO="${TARGET_RELEASE_REPO}"
            export BBX_RELEASE_TAG="${PRIVATE_TAG}"
            echo "Using private release ${BBX_RELEASE_REPO}@${BBX_RELEASE_TAG}"
          fi
          export INSTALL_DOC_VIEWER STATUS_MODE BBX_TEST_AGREEMENT LICENSE_KEY EMAIL BBX_HOSTNAME BB_QUICK_EXIT
          ./tests/test-bbx.sh
        continue-on-error: false

      - name: Execute BBX Test Saga (Windows)
        if: matrix.os == 'windows-latest'
        shell: powershell
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BBX_FORCE_CHROME_INSTALL: "true"
          BBX_HOSTNAME: "localhost"
          EMAIL: "test@example.com"
          BB_QUICK_EXIT: "surewhatevs"
          LICENSE_KEY: ${{ secrets.BB_LICENSE_KEY }}
          BBX_TEST_AGREEMENT: "true"
          STATUS_MODE: ${{ secrets.STATUS_MODE_KEY }}
          TARGET_RELEASE_REPO: ${{ env.TARGET_RELEASE_REPO }}
          PRIVATE_TAG: ${{ env.PRIVATE_TAG }}
        run: |
          if ($env:USE_PRIVATE_RELEASE -eq "true") {
            if ([string]::IsNullOrWhiteSpace($env:PRIVATE_TAG)) {
              Write-Error "PRIVATE_RELEASE_TAG is required when use_private_release=true"
            }
            $env:BBX_RELEASE_REPO = $env:TARGET_RELEASE_REPO
            $env:BBX_RELEASE_TAG = $env:PRIVATE_TAG
            Write-Host "Using private release $($env:BBX_RELEASE_REPO)@$($env:BBX_RELEASE_TAG)"
          }
          # Debug variables
          if (-not $env:BBX_HOSTNAME) { Write-Host "BBX_HOSTNAME is not set" } else { Write-Host "BBX_HOSTNAME is set" }
          if (-not $env:EMAIL) { Write-Host "EMAIL is not set" } else { Write-Host "EMAIL is set" }
          if (-not $env:LICENSE_KEY) { Write-Host "LICENSE_KEY is not set" } else { Write-Host "LICENSE_KEY is set" }
          if (-not $env:BBX_TEST_AGREEMENT) { Write-Host "BBX_TEST_AGREEMENT is not set" } else { Write-Host "BBX_TEST_AGREEMENT is set" }
          if (-not $env:STATUS_MODE) { Write-Host "STATUS_MODE is not set" } else { Write-Host "STATUS_MODE is set" }
          # Install BrowserBox from checked-out repo
          .\windows-scripts\bbx.ps1 install
          if (-not (Get-Command bbx -ErrorAction SilentlyContinue)) {
            Write-Error "bbx not found in PATH after install"
            exit 1
          }
          winget install cURL.cURL --silent --accept-source-agreements --accept-package-agreements
          if (-not (Get-Command curl.exe -ErrorAction SilentlyContinue)) {
            Write-Error "curl.exe not installed"
            exit 1
          }
          Write-Host "curl.exe installed successfully"
          bbx setup -Hostname "$env:BBX_HOSTNAME" -Email "$env:EMAIL" -Port 9999
          $loginLink = Get-Content "$env:USERPROFILE\.config\dosyago\bbpro\login.link"
          Write-Host "Login link: $loginLink"
          bbx run 
          Write-Host "Testing URL: $loginLink"
          $maxRetries = 10
          $retryCount = 0
          $success = $false
          while ($retryCount -lt $maxRetries -and -not $success) {
            try {
              $response = curl.exe -k -L "$loginLink" -o NUL -w "%{http_code}"
              if ($response -ne "000") {
                Write-Host "Initial connection successful: $response"
                $success = $true
              } else {
                Write-Host "Retry $($retryCount + 1)/$maxRetries failed: HTTP $response"
              }
            } catch {
              Write-Host "Retry $($retryCount + 1)/$maxRetries failed: $_"
            }
            if (-not $success) { Start-Sleep -Seconds 2; $retryCount++ }
          }
          if (-not $success) {
            Write-Error "Failed to connect to $loginLink after $maxRetries retries."
            exit 1
          }
          Write-Host "Waiting 25 seconds to verify link stability..."
          Start-Sleep -Seconds 25
          try {
            $response = curl.exe -k -L "$loginLink" -o NUL -w "%{http_code}"
            if ($response -ne "000") {
              Write-Host "Second verification successful: $response"
            } else {
              Write-Error "Second verification failed: HTTP $response"
              exit 1
            }
          } catch {
            Write-Error "Second verification failed after 25s: $_"
            exit 1
          }
          bbx stop
          $nodeProcs = Get-Process -Name "browserbox", "browserbox-devtools" -ErrorAction SilentlyContinue
          if ($nodeProcs) {
            Write-Error "Node processes still running after stop: $($nodeProcs | Format-List Name, Id | Out-String)"
          } else {
            Write-Host "No Node processes remain -- cleanup successful."
          }
     
      - name: Print BBX Logs on Failure (Windows)
        if: failure() && matrix.os == 'windows-latest'
        shell: powershell
        run: |
          $logDir = "$env:USERPROFILE\.config\dosyago\bbpro\logs"
          $logs = @("browserbox-main-out.log", "browserbox-main-err.log", "browserbox-devtools-out.log", "browserbox-devtools-err.log")
          foreach ($log in $logs) {
            $logPath = Join-Path $logDir $log
            if (Test-Path $logPath) {
              Write-Host "Contents of ${log}:"
              Get-Content $logPath
            } else {
              Write-Host "$log not found."
            }
          }

      - name: Cleanup (Unix/macOS)
        if: always() && matrix.os != 'windows-latest'
        shell: bash
        run: |
          # Try multiple cleanup methods
          if [ -x ./bbx.sh ]; then
            ./bbx.sh stop || true
          elif command -v bbx &>/dev/null; then
            bbx stop || true
          fi
          # Kill any remaining browserbox processes
          pkill -f browserbox || true
