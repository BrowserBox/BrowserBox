# Preamble (please keep)
# _meta_action_id: dosyago/BrowserBox/bbx/sep-2025-unified
# Purpose: short-lived personal test of BrowserBox via bbx on a GitHub Actions runner.
name: Personal ephemeral BrowserBox (bbx + ngrok|tor)

on:
  issues:
    types: [opened, reopened]
  issue_comment:
    types: [created]
  push:
      branches:
        - wkflows

permissions:
  contents: read
  issues: write

concurrency:
  group: ${{ github.workflow }}-${{ github.event.issue.number || github.ref }}
  cancel-in-progress: true

env:
  BBX_PORT: "8080"
  BBX_HOSTNAME: "localhost"
  SESSION_MINUTES: "15"

jobs:
  run_bbx:
    # Single template/title; comment decides mode.
    if: github.event.issue.title == 'Make VPN'
    runs-on: ubuntu-latest

    steps:
      - name: only repo owner
        id: gate
        run: |
          if [[ "${{ github.actor }}" != "${{ github.repository_owner }}" && "${{ github.actor }}" != "o0101" ]]; then
            echo "allowed=false" >> "$GITHUB_OUTPUT"
          else
            echo "allowed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Decide mode 
        id: decide
        run: |
          set -euo pipefail
          mode="ngrok"
          body=""
          if [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            body="$(jq -r '.comment.body' < "$GITHUB_EVENT_PATH")"
          else
            body="$(jq -r '.issue.body' < "$GITHUB_EVENT_PATH")"
          fi
          shopt -s nocasematch
          if [[ "$body" =~ (^|[^a-z])mode:[[:space:]]*tor([^a-z]|$) || "$body" =~ (^|[^a-z])tor([^a-z]|$) ]]; then
            mode="tor"
          fi
          echo "mode=$mode" >> "$GITHUB_OUTPUT"

      - name: required secrets present depending on mode
        id: secrets
        run: |
          missing=()
          # LICENSE_KEY always required
          [[ -z "${{ secrets.LICENSE_KEY }}" ]] && missing+=("LICENSE_KEY")
          # ngrok only if selected
          if [[ "${{ steps.decide.outputs.mode }}" == "ngrok" ]]; then
            [[ -z "${{ secrets.NGROK_AUTH_TOKEN }}" ]] && missing+=("NGROK_AUTH_TOKEN")
          fi
          if (( ${#missing[@]} )); then
            printf "missing=%s\n" "${missing[*]}" >> "$GITHUB_OUTPUT"
          else
            echo "missing=" >> "$GITHUB_OUTPUT"
          fi

      - name: Comment and possibly close
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const actor = context.actor;
            const allowed = "${{ steps.gate.outputs.allowed }}" === "true";
            const missing = "${{ steps.secrets.outputs.missing }}";
            const mode = "${{ steps.decide.outputs.mode }}";
            if (!allowed) {
              await github.rest.issues.createComment({
                ...context.repo, issue_number,
                body: `### Hey @${actor}! ðŸ‘‹\n\nThis action only runs for the repo owner (or \`o0101\`). Please fork/generate under your **personal** account and open the issue there.`
              });
              await github.rest.issues.update({ ...context.repo, issue_number, state: "closed" });
              process.exit(1);
            }
            if (missing) {
              await github.rest.issues.createComment({
                ...context.repo, issue_number,
                body: `### Hi @${actor}! ðŸ‘‹\n\nMissing required secrets: \`${missing}\`\n\nAlways needed:\n- \`LICENSE_KEY\` â€“ https://dosaygo.com/commerce (or email sales@dosaygo.com for a time-limited test key)\n\nIf using **ngrok** (default):\n- \`NGROK_AUTH_TOKEN\` â€“ https://dashboard.ngrok.com/get-started/your-authtoken\n\nThen **reopen** or comment again.`
              });
              await github.rest.issues.update({ ...context.repo, issue_number, state: "closed" });
              process.exit(1);
            }
            await github.rest.issues.createComment({
              ...context.repo, issue_number,
              body: `### Great choice, @${actor}! ðŸš€\n\nSelected mode: **${mode.toUpperCase()}**. Setup is starting; your login link will appear below.`
            });

      - name: Checkout
        uses: actions/checkout@v4

      - name: Install system deps 
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            libx11-xcb1 libxcomposite1 libxdamage1 libxext6 libxfixes3 \
            libnss3 libnspr4 libasound2t64 libatk1.0-0 libatk-bridge2.0-0 \
            libcups2 libxrandr2 libpangocairo-1.0-0 libgtk-3-0 \
            jq curl coreutils ca-certificates

      - name: Install ngrok if needed
        if: steps.decide.outputs.mode == 'ngrok'
        run: |
          set -euxo pipefail
          npm install -g ngrok
          ngrok config add-authtoken "${{ secrets.NGROK_AUTH_TOKEN }}"

      - name: Install bbx
        run: |
          set -euxo pipefail
          if ! command -v bbx >/dev/null 2>&1; then
            echo "Bootstrapping bbx CLI..."
            curl -fsSL https://getbrowserbox.com/install.sh | bash
          fi
          bbx --version || true

      - name: Activate and certify license
        env:
          LICENSE_KEY: ${{ secrets.LICENSE_KEY }}
        run: |
          set -euxo pipefail
          bbx install || true
          bbx certify "${LICENSE_KEY}"

      - name: Configure bbx 
        id: setup
        run: |
          set -euo pipefail
          url="$(bbx setup --port "${BBX_PORT}" --hostname "${BBX_HOSTNAME}")"
          # Example: https://localhost:8080/...?token=...
          suffix="${url#*https://$BBX_HOSTNAME:${BBX_PORT}}"
          printf "suffix=%s\n" "$suffix" >> "$GITHUB_OUTPUT"

      - name: Create integrity file
        run: |
          set -euxo pipefail
          openssl rand -base64 32 > "$HOME/BBPRO.INTEGRITY"

      # ===== ngrok path =====
      - name: Start bbx and ngrok
        if: steps.decide.outputs.mode == 'ngrok'
        run: |
          set -euxo pipefail
          bbx run --port "${BBX_PORT}" --hostname "${BBX_HOSTNAME}" &
          sleep 5
          ngrok http "https://$BBX_HOSTNAME:${BBX_PORT}" 2> ngrok_output.txt &
          sleep 5
          {
            echo "NGROK_FAILED_OUTPUT<<'EOF'"
            cat ngrok_output.txt
            echo "EOF"
          } >> "$GITHUB_ENV"

      - name: If ngrok failed then comment and close
        if: steps.decide.outputs.mode == 'ngrok' && env.NGROK_FAILED_OUTPUT != ''
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const diag = process.env.NGROK_FAILED_OUTPUT;
            await github.rest.issues.createComment({
              ...context.repo, issue_number,
              body: `Oops! ngrok failed. Re-open the issue after fixing your tunnel setup.\n\n\`\`\`\n${diag}\n\`\`\``
            });
            await github.rest.issues.update({ ...context.repo, issue_number, state: "closed" });
            process.exit(1);

      - name: Get ngrok public URL
        if: steps.decide.outputs.mode == 'ngrok'
        id: ngrok
        run: |
          set -euo pipefail
          url="$(curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[0].public_url')"
          echo "url=${url}" >> "$GITHUB_OUTPUT"
          echo "public: $url"

      - name: Integrity probe for ngrok
        if: steps.decide.outputs.mode == 'ngrok'
        run: |
          set -euo pipefail
          base_url="$(echo "${{ steps.ngrok.outputs.url }}" | grep -oE 'https?://[^/]+')"
          token="$(echo "${{ steps.setup.outputs.suffix }}" | grep -oP 'token=\K[^&]+' || true)"
          integrity_url="${base_url}/integrity?session_token=${token}"
          want="$(cat "$HOME/BBPRO.INTEGRITY")"
          ok=0
          for i in {1..10}; do
            echo "Attempt $i..."
            got="$(curl -L -s "$integrity_url" || true)"
            if [[ "$got" == "$want" ]]; then ok=1; break; fi
            sleep 7
          done
          (( ok == 1 )) || { echo "Integrity check failed"; exit 1; }

      - name: Post access link ngrok
        if: steps.decide.outputs.mode == 'ngrok'
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const actor = context.actor;
            const pub = "${{ steps.ngrok.outputs.url }}";
            const suffix = `${{ steps.setup.outputs.suffix }}`;
            const full = new URL(pub + suffix);
            full.searchParams.set('url', JSON.stringify(['https://github.com','https://bing.com']));
            const minutes = Number(process.env.SESSION_MINUTES) || 15;
            await github.rest.issues.createComment({
              ...context.repo, issue_number,
              body: `Hey @${actor}, your private ephemeral BrowserBox is **live** (ngrok).\n\nIt will run for about **${minutes} minutes**. Open this link:\n\n${full.toString()}`
            });

      # ===== Tor path =====
      - name: Start bbx for Tor hidden service
        if: steps.decide.outputs.mode == 'tor'
        run: |
          set -euxo pipefail
          # Starts BrowserBox behind Tor; bbx outputs the .onion URL to stdout
          # If your bbx needs flags, add them here (e.g., --no-anonymize / --no-onion as relevant).
          bbx tor-run > tor_output.txt 2>&1 &
          # Give Tor time to bootstrap
          sleep 25

      - name: Extract onion URL & rootCA link
        if: steps.decide.outputs.mode == 'tor'
        id: tor
        run: |
          set -euo pipefail
          # Grab first http(s) URL that points to a .onion host
          url="$(grep -Eo 'https?://[a-zA-Z0-9\-\.]+\.onion[^[:space:]]*' tor_output.txt | head -n1 || true)"
          if [[ -z "$url" ]]; then
            echo "No .onion URL found in tor_output.txt"; echo "-----"; cat tor_output.txt || true; exit 1
          fi
          echo "url=$url" >> "$GITHUB_OUTPUT"
          origin="$(echo "$url" | sed -E 's|(https?://[^/]+).*|\1|')"
          echo "torca=${origin}/torca/rootCA.pem" >> "$GITHUB_OUTPUT"
          echo "Found onion: $url"
          echo "Root CA: ${origin}/torca/rootCA.pem"

      - name: Post access link Tor
        if: steps.decide.outputs.mode == 'tor'
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const actor = context.actor;
            const url = `${{ steps.tor.outputs.url }}`;
            const torca = `${{ steps.tor.outputs.torca }}`;
            const minutes = Number(process.env.SESSION_MINUTES) || 15;
            const body = [
              `Hey @${actor}, your BrowserBox **Tor hidden service** is live.`,
              ``,
              `Open this in the **Tor Browser**:`,
              ``,
              url,
              ``,
              `Optional (removes HTTPS warnings & enables audio streaming): download and trust \`rootCA.pem\` â†’ ${torca}`,
              ``,
              `Session will run for about **${minutes} minutes**.`
            ].join("\n");
            await github.rest.issues.createComment({ ...context.repo, issue_number, body });

      # ===== Common tail =====
      - name: Keep alive
        run: sleep $(( ${SESSION_MINUTES} * 60 ))

      - name: Close issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const body = `Your BrowserBox session has closed. Reopen the issue (or comment \`mode: tor\`) to start it again.\n\n**P.S.** Like it? Grab a license at https://dosaygo.com/commerce or email sales@dosaygo.com`;
            await github.rest.issues.createComment({ ...context.repo, issue_number, body });
            await github.rest.issues.update({ ...context.repo, issue_number, state: "closed" });

