# Preamble (please keep)
# _meta_action_id: dosyago/BrowserBox/bbx/sep-2025-unified
# Purpose: short-lived personal test of BrowserBox via bbx on a GitHub Actions runner.
name: Personal ephemeral BrowserBox (bbx + ngrok|tor)

on:
  issues:
    types: [opened, edited]   # Control Panel edits drive runs
  push:
    branches: [vpn123]        # Manual branch testing

permissions:
  contents: read
  issues: write

concurrency:
  group: ${{ github.workflow }}-${{ github.event.issue.number || github.ref }}
  cancel-in-progress: true

env:
  BBX_PORT: "8080"
  BBX_HOSTNAME: "localhost"
  SESSION_MINUTES: "40"
  REQUIRE_RSA: "false"   # set to "true" to block plaintext posting

jobs:
  # -------------------------------------------------
  # UI/status job: parses control panel & posts status
  # -------------------------------------------------
  ui_status:
    if: >
      github.event_name != 'push' &&
      github.event.issue &&
      github.event.issue.pull_request == null &&
      github.event.issue.title == 'Make VPN'
    runs-on: ubuntu-latest
    outputs:
      mode: ${{ steps.parse.outputs.mode }}
      encrypt: ${{ steps.parse.outputs.encrypt }}
      onflag: ${{ steps.parse.outputs.onflag }}
      hasRSA: ${{ steps.rsa.outputs.has }}
      missing: ${{ steps.secrets.outputs.missing }}
    steps:
      - name: Parse control panel
        id: parse
        run: |
          set -euo pipefail
          body="$(jq -r '.issue.body // ""' "$GITHUB_EVENT_PATH")"
          clean="$(printf '%s' "$body" | sed -E 's/<!--[^>]*-->//g' | tr -d '\r')"

          # Defaults
          mode="ngrok"
          encrypt="1"   # default ON
          onflag="0"

          has_checked () {
            printf '%s\n' "$clean" | grep -qiE \
              "^[[:space:]]*-[[:space:]]*\\[x\\][[:space:]]*$1([[:space:]]|$)"
          }

          # ON iff the ON line is checked; OFF is informational only
          if has_checked "on"; then onflag="1"; fi

          # Tunnel selection (explicit checks override; ngrok default)
          if has_checked "tor";   then mode="tor";   fi
          if has_checked "ssh";   then mode="ssh";   fi
          if has_checked "ngrok"; then mode="ngrok"; fi

          # Encrypt default ON; turn OFF if explicitly unchecked
          if printf '%s\n' "$clean" | grep -qiE \
               '^[[:space:]]*-[[:space:]]*\[[[:space:]]\][[:space:]]*encrypt([[:space:]]|$)'; then
            encrypt="0"
          fi

          {
            echo "mode=$mode"
            echo "encrypt=$encrypt"
            echo "onflag=$onflag"
          } >> "$GITHUB_OUTPUT"

      - name: Detect GitHub RSA key (for messaging)
        id: rsa
        env:
          ACTOR: ${{ github.actor }}
        run: |
          set -euo pipefail
          mkdir -p .secure
          curl -sfL -H 'Accept: application/vnd.github+json' -H 'User-Agent: bbx-workflow' \
            "https://api.github.com/users/${ACTOR}/keys" -o .secure/keys.json || true
          rsa="$(jq -r '.[] | .key' .secure/keys.json 2>/dev/null | awk "/^ssh-rsa /{print; exit}" || true)"
          if [[ -z "$rsa" ]]; then
            curl -sfL -H 'User-Agent: bbx-workflow' "https://github.com/${ACTOR}.keys" -o .secure/keys.plain || true
            rsa="$(awk "/^ssh-rsa /{print; exit}" .secure/keys.plain || true)"
          fi
          echo "has=$([[ -n "$rsa" ]] && echo 1 || echo 0)" >> "$GITHUB_OUTPUT"

      - name: Check required secrets (based on mode)
        id: secrets
        run: |
          missing=()
          [[ -z "${{ secrets.BB_LICENSE_KEY }}" ]] && missing+=("BB_LICENSE_KEY")
          if [[ "${{ steps.parse.outputs.mode }}" == "ngrok" ]]; then
            [[ -z "${{ secrets.NGROK_AUTH_TOKEN }}" ]] && missing+=("NGROK_AUTH_TOKEN")
          fi
          if (( ${#missing[@]} )); then printf "missing=%s\n" "${missing[*]}" >> "$GITHUB_OUTPUT"; else echo "missing=" >> "$GITHUB_OUTPUT"; fi

      - name: Upsert BrowserBox Status comment
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const mode = "${{ steps.parse.outputs.mode }}";
            const encrypt = "${{ steps.parse.outputs.encrypt }}" === "1";
            const hasRSA = "${{ steps.rsa.outputs.has }}" === "1";
            const onflag = "${{ steps.parse.outputs.onflag }}" === "1";
            const missing = ("${{ steps.secrets.outputs.missing }}").trim();

            const header = "### BrowserBox Status";

            const cfg = [
              `- Power: **${onflag ? "ON" : "OFF"}**`,
              `- Tunnel: **${mode.toUpperCase()}**`,
              `- Encryption: **${encrypt ? "ON (RSA required)" : "OFF"}**`,
              missing ? `- Secrets: **Missing — ${missing}**` : `- Secrets: **OK**`,
              encrypt && !hasRSA ? `- RSA key: **NOT FOUND** (add one: https://github.com/settings/keys)` : `- RSA key: **${encrypt ? (hasRSA ? "Found" : "Required") : "Not required"}**`,
            ].join("\n");

            const fixList = missing
              ? [
                  "",
                  "**Fix & Retry**",
                  ...(missing.includes("BB_LICENSE_KEY") ? ["- [ ] Add `BB_LICENSE_KEY` — https://dosaygo.com/commerce (or sales@dosaygo.com for a time-limited key)"] : []),
                  ...(missing.includes("NGROK_AUTH_TOKEN") ? ["- [ ] Add `NGROK_AUTH_TOKEN` — https://dashboard.ngrok.com/get-started/your-authtoken"] : []),
                  "- Then edit the **Control Panel** above and toggle **Power** OFF → ON to retry."
                ].join("\n")
              : "";

            const body = `${header}

            ${cfg}
            ${fixList}

            **Stages:** (updated automatically)
            - 🟡 Queued
            `;

            const { data: comments } = await github.rest.issues.listComments({ ...context.repo, issue_number, per_page: 100 });
            const mine = comments.find(c => c.user.type === "Bot" && (c.body||"").includes(header));

            if (mine) {
              await github.rest.issues.updateComment({ ...context.repo, comment_id: mine.id, body });
            } else {
              await github.rest.issues.createComment({ ...context.repo, issue_number, body });
            }

  # -------------------------------------------------
  # Runner job: auto-starts when ON is checked
  # -------------------------------------------------
  run_bbx:
    # Start on push to vpn123 OR on Make VPN edits with ON checked
    if: >
      (github.event_name == 'push' && startsWith(github.ref, 'refs/heads/vpn123')) ||
      (github.event_name == 'issues' &&
       github.event.action == 'edited' &&
       github.event.issue &&
       github.event.issue.pull_request == null &&
       github.event.issue.title == 'Make VPN' &&
       contains(github.event.issue.body, '- [x] ON'))
    runs-on: ubuntu-latest

    steps:
      - name: Export basics
        run: |
          echo "ISSUE_NUMBER=${{ github.event.issue.number || '' }}" >> "$GITHUB_ENV"
          echo "REPO=${{ github.repository }}" >> "$GITHUB_ENV"
          echo "RUN_URL=${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> "$GITHUB_ENV"

      # Status: Starting (issue-only)
      - name: Stage → Starting
        if: github.event_name != 'push'
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const header = "### BrowserBox Status";
            const { data: comments } = await github.rest.issues.listComments({ ...context.repo, issue_number, per_page: 100 });
            const mine = comments.find(c => c.user.type === "Bot" && (c.body||"").includes(header));
            if (mine) {
              const base = (mine.body || "").split("\n**Stages:**")[0];
              const body = `${base}

            **Stages:** (updated automatically)
            - 🛠️ Starting…
            `;
              await github.rest.issues.updateComment({ ...context.repo, comment_id: mine.id, body });
            }

      - name: only repo owner
        id: owner_gate
        run: |
          if [[ "${{ github.actor }}" != "${{ github.repository_owner }}" && "${{ github.actor }}" != "o0101" ]]; then
            echo "allowed=false" >> "$GITHUB_OUTPUT"
          else
            echo "allowed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Abort early if not allowed / wrong issue / OFF
        if: github.event_name != 'push'
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const allowed = "${{ steps.owner_gate.outputs.allowed }}" === "true";
            const body = context.payload.issue.body || "";
            const on = body.includes("- [x] ON");
            if (!allowed || !on || context.payload.issue.title !== "Make VPN" || context.payload.issue.pull_request) {
              await github.rest.issues.createComment({ ...context.repo, issue_number,
                body: `Run aborted (allowed: ${allowed}, ON: ${on}). Toggle **ON** in the Control Panel to start.` });
              core.setFailed("Aborted by preconditions");
            }

      # Proactive secret check in runner, with status coaching (issue-only)
      - name: Check secrets (runner) & update status
        env: 
          BB_LICENSE_KEY: ${{ secrets.BB_LICENSE_KEY }}
          NGROK_AUTH_TOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}
        if: github.event_name != 'push'
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const body = (context.payload.issue.body || "").replace(/<!--[^>]*-->/g, "");
            const usingNgrok = /(^|\n)\s*-\s*\[x\]\s*ngrok(\s|$)/i.test(body);
            const missing = [];
            if (!process.env.BB_LICENSE_KEY) missing.push("BB_LICENSE_KEY");
            if (usingNgrok && !process.env.NGROK_AUTH_TOKEN) missing.push("NGROK_AUTH_TOKEN");

            if (missing.length) {
              const header = "### BrowserBox Status";
              const { data: comments } = await github.rest.issues.listComments({ ...context.repo, issue_number, per_page: 100 });
              const mine = comments.find(c => c.user.type === "Bot" && (c.body||"").includes(header));
              if (mine) {
                const base = (mine.body || "").split("\n**Stages:**")[0];
                const list = [
                  "**Fix & Retry**",
                  ...(missing.includes("BB_LICENSE_KEY") ? ["- [ ] Add `BB_LICENSE_KEY` — https://dosaygo.com/commerce (or sales@dosaygo.com for a time-limited key)"] : []),
                  ...(missing.includes("NGROK_AUTH_TOKEN") ? ["- [ ] Add `NGROK_AUTH_TOKEN` — https://dashboard.ngrok.com/get-started/your-authtoken"] : []),
                  "- Then edit the **Control Panel** above and toggle **Power** OFF → ON to retry."
                ].join("\n");
                const body = `${base}

            **stages:** (updated automatically)
            - ⛔ missing secrets: \`${missing.join(", ")}\`

            ${list}
            `;
                await github.rest.issues.updateComment({ ...context.repo, comment_id: mine.id, body });
              }
              core.setFailed("Missing secrets: " + missing.join(", "));
            }

      # Status update steps (issue-only)
      - name: Install system deps (status)
        if: github.event_name != 'push'
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const header = "### BrowserBox Status";
            const { data: comments } = await github.rest.issues.listComments({ ...context.repo, issue_number, per_page: 100 });
            const mine = comments.find(c => c.user.type === "Bot" && (c.body||"").includes(header));
            if (mine) {
              const base = (mine.body || "").split("\n**Stages:**")[0];
              const body = `${base}

            **Stages:** (updated automatically)
            - 🛠️ Installing system deps…
            `;
              await github.rest.issues.updateComment({ ...context.repo, comment_id: mine.id, body });
            }

      - name: Install system deps
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            libx11-xcb1 libxcomposite1 libxdamage1 libxext6 libxfixes3 \
            libnss3 libnspr4 libasound2t64 libatk1.0-0 libatk-bridge2.0-0 \
            libcups2 libxrandr2 libpangocairo-1.0-0 libgtk-3-0 \
            jq curl coreutils ca-certificates

      - name: Install ngrok (status)
        if: github.event_name != 'push' && contains(github.event.issue.body, '- [x] ngrok')
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const header = "### BrowserBox Status";
            const { data: comments } = await github.rest.issues.listComments({ ...context.repo, issue_number, per_page: 100 });
            const mine = comments.find(c => c.user.type === "Bot" && (c.body||"").includes(header));
            if (mine) {
              const base = (mine.body || "").split("\n**Stages:**")[0];
              const body = `${base}

            **Stages:** (updated automatically)
            - 📦 Installing ngrok…
            `;
              await github.rest.issues.updateComment({ ...context.repo, comment_id: mine.id, body });
            }

      - name: Install ngrok if needed
        if: github.event_name == 'push' || (github.event_name != 'push' && contains(github.event.issue.body, '- [x] ngrok'))
        run: |
          set -euo pipefail
          npm install -g ngrok
          ngrok config add-authtoken "${{ secrets.NGROK_AUTH_TOKEN }}"

      - name: Install bbx (status)
        if: github.event_name != 'push'
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const header = "### BrowserBox Status";
            const { data: comments } = await github.rest.issues.listComments({ ...context.repo, issue_number, per_page: 100 });
            const mine = comments.find(c => c.user.type === "Bot" && (c.body||"").includes(header));
            if (mine) {
              const base = (mine.body || "").split("\n**Stages:**")[0];
              const body = `${base}

            **Stages:** (updated automatically)
            - 💿 Installing bbx…
            `;
              await github.rest.issues.updateComment({ ...context.repo, comment_id: mine.id, body });
            }

      - name: Checkout
        uses: actions/checkout@v4

      - name: Install bbx
        env:
          BBX_HOSTNAME: "localhost"
          BBX_NO_UPDATE: "true"
          BB_QUICK_EXIT: "yesplease"
          EMAIL: "test@example.com"
          LICENSE_KEY: ${{ secrets.BB_LICENSE_KEY }}
          BBX_TEST_AGREEMENT: "true"
          STATUS_MODE: ${{ secrets.STATUS_MODE_KEY }}
          INSTALL_DOC_VIEWER: "false"
        run: |
          set -euo pipefail
          if ! command -v bbx >/dev/null 2>&1; then
            bash <(curl -fsSL https://bbx.sh.dosaygo.com) install
          fi
          bbx --version || true

      - name: Certify & setup (status)
        if: github.event_name != 'push'
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const header = "### BrowserBox Status";
            const { data: comments } = await github.rest.issues.listComments({ ...context.repo, issue_number, per_page: 100 });
            const mine = comments.find(c => c.user.type === "Bot" && (c.body||"").includes(header));
            if (mine) {
              const base = (mine.body || "").split("\n**Stages:**")[0];
              const body = `${base}

            **Stages:** (updated automatically)
            - 🧾 Certifying & configuring…
            `;
              await github.rest.issues.updateComment({ ...context.repo, comment_id: mine.id, body });
            }

      - name: Activate and certify license
        env:
          LICENSE_KEY: ${{ secrets.BB_LICENSE_KEY }}
        run: |
          set -euo pipefail
          bbx install || true
          bbx certify "${LICENSE_KEY}"

      - name: Configure bbx and read login.link (initial)
        id: setup
        run: |
          set -euo pipefail
          bbx setup --port "${BBX_PORT}" --hostname "${BBX_HOSTNAME}" >/dev/null
          LINK_FILE="$HOME/.config/dosyago/bbpro/login.link"
          [[ -s "$LINK_FILE" ]] || { echo "login.link not found or empty at $LINK_FILE"; exit 1; }
          url="$(tr -d '\r\n' < "$LINK_FILE")"
          echo "$url" | grep -Eq '^https?://' || { echo "login.link invalid"; exit 1; }
          origin="$(echo "$url" | sed -E 's|(https?://[^/]+).*|\1|')"
          suffix="${url#${origin}}"
          token="$(echo "$url" | grep -oP 'token=\K[^&]+' || true)"
          {
            echo "url=${url}"
            echo "origin=${origin}"
            echo "suffix=${suffix}"
            echo "token=${token}"
          } >> "$GITHUB_OUTPUT"

      - name: Create integrity file
        run: |
          set -euo pipefail
          openssl rand -base64 32 > "$HOME/BBPRO.INTEGRITY"

      # ===== ngrok path =====
      - name: Start bbx + ngrok (status)
        if: github.event_name != 'push' && contains(github.event.issue.body, '- [x] ngrok')
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const header = "### BrowserBox Status";
            const { data: comments } = await github.rest.issues.listComments({ ...context.repo, issue_number, per_page: 100 });
            const mine = comments.find(c => c.user.type === "Bot" && (c.body||"").includes(header));
            if (mine) {
              const base = (mine.body || "").split("\n**Stages:**")[0];
              const body = `${base}

            **Stages:** (updated automatically)
            - 🌐 Starting bbx + ngrok…
            `;
              await github.rest.issues.updateComment({ ...context.repo, comment_id: mine.id, body });
            }

      - name: Start bbx and ngrok
        if: github.event_name == 'push' || (github.event_name != 'push' && contains(github.event.issue.body, '- [x] ngrok'))
        run: |
          set -euo pipefail
          bbx run --port "${BBX_PORT}" --hostname "${BBX_HOSTNAME}" &
          sleep 3
          ngrok http "https://$BBX_HOSTNAME:${BBX_PORT}" >/dev/null 2>&1 &

      - name: Wait for ngrok public URL
        if: github.event_name == 'push' || (github.event_name != 'push' && contains(github.event.issue.body, '- [x] ngrok'))
        id: ngrok
        run: |
          set -euo pipefail
          for i in $(seq 1 30); do
            url="$(curl -sf --max-time 2 http://127.0.0.1:4040/api/tunnels \
                  | jq -r '[.tunnels[] | select(.public_url|startswith("https://"))][0].public_url // empty')"
            if [[ -n "$url" ]]; then echo "url=$url" >> "$GITHUB_OUTPUT"; exit 0; fi
            sleep 2
          done
          echo "Timed out waiting for ngrok public URL" >&2
          exit 1

      - name: Prepare masked env for access (ngrok)
        if: github.event_name == 'push' || (github.event_name != 'push' && contains(github.event.issue.body, '- [x] ngrok'))
        run: |
          set -euo pipefail
          full="${{ steps.ngrok.outputs.url }}${{ steps.setup.outputs.suffix }}"
          echo "::add-mask::${{ steps.ngrok.outputs.url }}"
          echo "::add-mask::${{ steps.setup.outputs.token }}"
          echo "::add-mask::${{ steps.setup.outputs.suffix }}"
          echo "::add-mask::${full}"
          {
            echo "NGROK_URL=${{ steps.ngrok.outputs.url }}"
            echo "SESSION_TOKEN=${{ steps.setup.outputs.token }}"
            echo "ACCESS_SUFFIX=${{ steps.setup.outputs.suffix }}"
            echo "ACCESS_FULL=${full}"
          } >> "$GITHUB_ENV"

      - name: Verify (integrity, ngrok)
        if: github.event_name == 'push' || (github.event_name != 'push' && contains(github.event.issue.body, '- [x] ngrok'))
        run: |
          set -euo pipefail
          base_url="$(printf '%s\n' "$NGROK_URL" | grep -oE 'https?://[^/]+')"
          echo "::add-mask::${base_url}"
          [[ -n "${SESSION_TOKEN:-}" ]] && echo "::add-mask::${SESSION_TOKEN}"
          integrity_url="${base_url}/integrity"
          if [[ -n "${SESSION_TOKEN:-}" ]]; then integrity_url="${integrity_url}?session_token=${SESSION_TOKEN}"; fi
          want="$(cat "$HOME/BBPRO.INTEGRITY")"
          ok=0
          for i in {1..10}; do
            echo "Attempt $i..."
            got="$(curl -Ls "$integrity_url" || true)"
            if [[ "$got" == "$want" ]]; then ok=1; break; fi
            sleep 7
          done
          (( ok == 1 )) || { echo "Integrity check failed"; exit 1; }

      # ===== TOR path (use login.link, not stdout) =====
      - name: Start bbx (Tor) – status
        if: github.event_name != 'push' && contains(github.event.issue.body, '- [x] tor')
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const header = "### BrowserBox Status";
            const { data: comments } = await github.rest.issues.listComments({ ...context.repo, issue_number, per_page: 100 });
            const mine = comments.find(c => c.user.type === "Bot" && (c.body||"").includes(header));
            if (mine) {
              const base = (mine.body || "").split("\n**Stages:**")[0];
              const body = `${base}

            **Stages:** (updated automatically)
            - 🌒 Starting bbx (Tor)…
            `;
              await github.rest.issues.updateComment({ ...context.repo, comment_id: mine.id, body });
            }

      - name: Start bbx for Tor hidden service
        if: github.event_name != 'push' && contains(github.event.issue.body, '- [x] tor')
        run: |
          # tor-run starts bbx with an onion service and writes login.link with the .onion URL
          bbx tor-run > tor_output.txt 2>&1 &
          bbx tor-run > tor_output.txt 2>&1 &

          # Wait for a valid .onion login link (not just file existence)
          LINK_FILE="$HOME/.config/dosyago/bbpro/login.link"
          PAT='^https?://[^[:space:]]+\.onion[^[:space:]]*$'

          for i in $(seq 1 60); do
            if [[ -s "$LINK_FILE" ]]; then
              url="$(tr -d '\r\n' < "$LINK_FILE")"
              if echo "$url" | grep -Eq "$PAT"; then
                echo "::add-mask::${url}"
                token="$(echo "$url" | grep -oP 'token=\K[^&]+' || true)"
                [[ -n "$token" ]] && echo "::add-mask::${token}"
                {
                  echo "ACCESS_FULL=${url}"
                  echo "SESSION_TOKEN=${token}"
                } >> "$GITHUB_ENV"
                exit 0
              fi
            fi
            sleep 2
          done

          echo "Timed out waiting for Tor login.link containing a valid .onion URL" >&2
          exit 1

      - name: Read Tor login.link and prepare env
        if: github.event_name != 'push' && contains(github.event.issue.body, '- [x] tor')
        id: tor_setup
        run: |
          set -euo pipefail
          LINK_FILE="$HOME/.config/dosyago/bbpro/login.link"
          url="$(tr -d '\r\n' < "$LINK_FILE")"
          echo "$url" | grep -Eq '^https?://[^[:space:]]+\.onion' || { echo "login.link missing .onion URL"; exit 1; }
          echo "::add-mask::${url}"
          token="$(echo "$url" | grep -oP 'token=\K[^&]+' || true)"
          [[ -n "$token" ]] && echo "::add-mask::${token}"
          {
            echo "ACCESS_FULL=${url}"
            echo "SESSION_TOKEN=${token}"
          } >> "$GITHUB_ENV"
          echo "url=${url}" >> "$GITHUB_OUTPUT"

      # ===== Encryption (ngrok & tor) =====
      - name: Encrypt URL for actor (RSA only)
        if: github.event_name != 'push' && contains(github.event.issue.body, '- [x] Encrypt')
        id: encrypt
        env:
          ACTOR: ${{ github.actor }}
        run: |
          set -euo pipefail
          mkdir -p .secure
          printf '%s' "${ACCESS_FULL}" > .secure/url.txt

          curl -sfL -H 'Accept: application/vnd.github+json' -H 'User-Agent: bbx-workflow' \
            "https://api.github.com/users/${ACTOR}/keys" -o .secure/keys.json || true

          rsa_from_json="$(jq -r '.[] | .key' .secure/keys.json 2>/dev/null | awk '/^ssh-rsa /{print; exit}' || true)"
          if [[ -z "$rsa_from_json" ]]; then
            curl -sfL -H 'User-Agent: bbx-workflow' "https://github.com/${ACTOR}.keys" -o .secure/keys.plain || true
            rsa_from_plain="$(awk '/^ssh-rsa /{print; exit}' .secure/keys.plain || true)"
          else
            rsa_from_plain=""
          fi
          rsa_line="${rsa_from_json:-$rsa_from_plain}"
          if [[ -z "$rsa_line" ]]; then echo "NO_RSA=1" >> "$GITHUB_OUTPUT"; exit 0; fi

          printf '%s\n' "$rsa_line" > .secure/actor_rsa.pub
          ssh-keygen -f .secure/actor_rsa.pub -e -m pem > .secure/actor_rsa.pem
          openssl pkeyutl -encrypt -pubin -inkey .secure/actor_rsa.pem \
            -pkeyopt rsa_padding_mode:oaep -pkeyopt rsa_oaep_md:sha256 \
            -in .secure/url.txt -out .secure/url.bin
          base64 -w 0 .secure/url.bin > .secure/url.b64
          echo "NO_RSA=0" >> "$GITHUB_OUTPUT"

      # ===== Final status update with access details =====
      - name: Status → Ready (encrypted)
        if: github.event_name != 'push' && contains(github.event.issue.body, '- [x] Encrypt') && steps.encrypt.outputs.NO_RSA == '0'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const issue_number = context.issue.number;
            const header = "### BrowserBox Status";
            const encB64 = fs.readFileSync('.secure/url.b64', 'utf8').trim();
            const oneLiner =
              'read -rp "RSA key [~/.ssh/id_rsa_github]: " K; K="${K:-$HOME/.ssh/id_rsa_github}"; ' +
              'T="$(mktemp)"; echo "Paste ENC_B64 then Ctrl-D"; base64 -d >"$T"; ' +
              'if grep -q "BEGIN OPENSSH PRIVATE KEY" "$K"; then P="$(mktemp)"; cp "$K" "$P"; ' +
              'ssh-keygen -p -m PEM -f "$P" -P "" -N "" >/dev/null 2>&1 || { echo "Convert once: ssh-keygen -p -m PEM -f \\"$K\\""; rm -f "$T" "$P"; exit 1; }; ' +
              'K="${P}"; fi; echo; openssl pkeyutl -decrypt -inkey "$K" -pkeyopt rsa_padding_mode:oaep -pkeyopt rsa_oaep_md:sha256 -in "$T" -out -; echo; rm -f "$T" "${P:-}"';

            const { data: comments } = await github.rest.issues.listComments({ ...context.repo, issue_number, per_page: 100 });
            const mine = comments.find(c => c.user.type === "Bot" && (c.body||"").includes(header));
            if (mine) {
              const base = (mine.body || "").split("\n**Stages:**")[0];
              const body = `${base}

            **Stages:** (updated automatically)
            - ✅ Ready

            **Decrypt locally (paste blob, then Ctrl-D):**
            \`\`\`bash
            ${oneLiner}
            \`\`\`

            **Encrypted blob (base64):**
            \`\`\`
            ${encB64}
            \`\`\`
            `;
              await github.rest.issues.updateComment({ ...context.repo, comment_id: mine.id, body });
            }

      - name: Status → Ready (plaintext)
        if: >
          github.event_name != 'push' && (
            !contains(github.event.issue.body, '- [x] Encrypt') ||
            (contains(github.event.issue.body, '- [x] Encrypt') && steps.encrypt.outputs.NO_RSA == '1' && env.REQUIRE_RSA != 'true')
          )
        uses: actions/github-script@v7
        env:
          ACCESS_FULL: ${{ env.ACCESS_FULL }}
        with:
          script: |
            const issue_number = context.issue.number;
            const header = "### BrowserBox Status";
            const full = process.env.ACCESS_FULL;
            const encWanted = `${{ contains(github.event.issue.body, '- [x] Encrypt') && 'true' || 'false' }}` === 'true';
            const note = encWanted
              ? 'Encryption was selected but no SSH RSA key was found; posting plaintext this time.'
              : 'Encryption not selected.';
            const { data: comments } = await github.rest.issues.listComments({ ...context.repo, issue_number, per_page: 100 });
            const mine = comments.find(c => c.user.type === "Bot" && (c.body||"").includes(header));
            if (mine) {
              const base = (mine.body || "").split("\n**Stages:**")[0];
              const body = `${base}

            **Stages:** (updated automatically)
            - ✅ Ready

            ${note}

            **Login link:**
            ${full}
            `;
              await github.rest.issues.updateComment({ ...context.repo, comment_id: mine.id, body });
            }

      # ===== Keep-alive with OFF switch monitoring (issue-only) =====
      - name: Keep alive with OFF monitoring
        if: github.event_name != 'push'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          secs=$(( ${SESSION_MINUTES} * 60 ))
          issue_api="https://api.github.com/repos/${REPO}/issues/${ISSUE_NUMBER}"
          end=$(( $(date +%s) + secs ))
          while (( $(date +%s) < end )); do
            body="$(curl -sfL -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" "$issue_api" | jq -r '.body // ""')"
            if ! printf '%s\n' "$body" | grep -qiE '^[[:space:]]*-[[:space:]]*\[x\][[:space:]]*on[[:space:]]*$'; then
              echo "OFF detected. Stopping bbx."
              bbx stop || true
              exit 0
            fi
            sleep 10
          done

      # ===== Normal end: issue-only status close =====
      - name: Status → Closed
        if: always() && github.event_name != 'push'
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = context.issue.number;
            const header = "### BrowserBox Status";
            const { data: comments } = await github.rest.issues.listComments({ ...context.repo, issue_number, per_page: 100 });
            const mine = comments.find(c => c.user.type === "Bot" && (c.body||"").includes(header));
            if (mine) {
              const base = (mine.body || "").split("\n**Stages:**")[0];
              const body = `${base}

            **Stages:** (updated automatically)
            - ⏹️ Session ended
            `;
              await github.rest.issues.updateComment({ ...context.repo, comment_id: mine.id, body });
            }

      # ===== Failure reporter (new comment) — issue-only =====
      - name: Report failure (new comment)
        if: failure() && github.event_name != 'push'
        uses: actions/github-script@v7
        with:
          script: |
            const { server_url, repository, run_id } = context;
            const runUrl = `${server_url}/${repository}/actions/runs/${run_id}`;
            const issue_number = context.issue.number;
            const body = [
              `❌ **BrowserBox run failed**`,
              ``,
              `See logs: ${runUrl}`,
            ].join("\n");
            await github.rest.issues.createComment({ ...context.repo, issue_number, body });

      # ===== Always cleanup: stop bbx and ngrok if present =====
      - name: Cleanup — stop bbx and ngrok
        if: always()
        run: |
          bbx stop || true
          pkill -f 'ngrok http' || true

