# Preamble
# Hello GitHub Folken - if this is violating the terms of service and you work for GitHub, 
#  please let me know and I will remove this action ASAP!
#  to make any automated removal easy I add the following pseudo key metadata
# _meta_action_id: dosyago/BrowserBox/tech-prototype/july-2023
# Do not remove this preamble
# Purpose
# Run BrowserBox on GitHub Actions Runner to Integration Test
#  This is intended as a useful technology prototype showing the ability to run the BrowserBox remote browser
#  on GitHub Actions Runners. This makes it easy to see if the application is working correctly, and to test 
#  any modifications you make. This is not an endorsement or encouragement to utilize GitHub Actions in a way that violates
#  the terms of service, as using this in excess may do that. Don't abuse the power and benevolence of the platform.
# End preamble

name: BrowserBox Basic Install Test

on:
  pull_request:
    types: [synchronize, opened, reopened]
  push:
    branches:
      - main

concurrency:
  group: ${{ github.repository }}-basic-install
  cancel-in-progress: true

jobs:
  build:
    name: browserbox basic install
    continue-on-error: ${{ matrix.os == 'windows-latest' }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
        container_image:
          - ''  # No container (native runner)
          - 'dokken/centos-stream-9'
          - 'debian:latest'
        exclude:
          - os: macos-latest  # macOS runners donâ€™t support containers
            container_image: 'dokken/centos-stream-9'
          - os: macos-latest
            container_image: 'debian:latest'
    runs-on: ${{ matrix.os }}
    timeout-minutes: 20
    container: ${{ matrix.container_image }}

    steps:
      # Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v4

      # Check if actor is repository owner or me
      - name: Check if actor is repository owner or me
        run: |
          if [[ "${{ github.actor }}" != "o0101" ]]; then
            echo "Actor is not me. Not running CI"
            exit 1
          fi

      # Install dependencies (Ubuntu Native)
      - name: Install dependencies (Ubuntu Native)
        if: matrix.os == 'ubuntu-latest' && matrix.container_image == ''
        run: |
          sudo apt-get update -y
          sudo apt-get install -y curl 

      # Install dependencies (Debian Container)
      - name: Install dependencies (Debian Container)
        if: matrix.container_image == 'debian:latest'
        run: |
          apt-get update -y
          apt-get install -y curl

      # Install dependencies (CentOS Container)
      - name: Install dependencies (CentOS Container)
        if: matrix.container_image == 'dokken/centos-stream-9'
        run: |
          dnf update -y
          dnf install -y curl

      # Install ngrok (cross-platform, with conditional setup for containers)
      - name: Install ngrok
        shell: /bin/bash {0}
        run: |
          if [[ "${{ matrix.container_image }}" != "" ]]; then
            # Container case: Install nvm and Node.js
            curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # Load nvm
            nvm install 22
            nvm use 22
            nvm alias default 22
            # Ensure npm is available and install ngrok
            . "$NVM_DIR/nvm.sh"  # Source nvm again for this shell
            npm install -g ngrok
          else
            # Non-container case: Use pre-installed Node.js
            npm install ngrok -g
          fi

      # Configure ngrok
      - name: Configure ngrok
        shell: /bin/bash {0}
        run: |
          source $HOME/.nvm/nvm.sh
          ngrok config add-authtoken ${{ secrets.NGROK_AUTH_TOKEN }}
        env:
          NGROK_AUTH_TOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}

      # Install application
      - name: Install application
        shell: /bin/bash {0}
        run: |
          yes | ./deploy-scripts/global_install.sh localhost

      # Configure application
      - name: Configure application
        id: setup
        shell: /bin/bash {0}
        run: |
          output=$(setup_bbpro --port 8080)
          echo "::set-output name=suffix::${output#*https://localhost:8080}"

      # Create BBPRO.INTEGRITY file
      - name: Create BBPRO.INTEGRITY file
        shell: /bin/bash {0}
        run: |
          random_string=$(openssl rand -base64 32)
          echo "$random_string" > $HOME/BBPRO.INTEGRITY

      # Start server & ngrok tunnel
      - name: Start server & ngrok tunnel
        shell: /bin/bash {0}
        run: |
          source $HOME/.nvm/nvm.sh
          export STATUS_MODE=${{ secrets.STATUS_MODE_KEY }}
          export LICENSE_KEY=${{ secrets.BB_LICENSE_KEY }}
          bbcertify
          export LICENSE_KEY=""
          bbpro &
          sleep 5
          ngrok http https://localhost:8080 &
          sleep 5

      # Get ngrok public URL
      - name: Get ngrok public URL
        id: ngrok
        shell: /bin/bash {0}
        run: |
          url=$(curl http://localhost:4040/api/tunnels | jq -r '.tunnels[0].public_url')
          suffix=${{ steps.setup.outputs.suffix }}
          complete_url="${url}${suffix}"
          echo "::set-output name=url::$complete_url"
          echo $complete_url

      # Check integrity route
      - name: Check integrity route
        shell: /bin/bash {0}
        run: |
          base_url=$(echo "${{ steps.ngrok.outputs.url }}" | grep -oE 'https?://[^/]+')
          token=$(echo "${{ steps.ngrok.outputs.url }}" | grep -oE 'token=[^&]+' | sed 's/token=//') 
          integrity_url="${base_url}/integrity?session_token=${token}"
          integrity_file_content=$(cat $HOME/BBPRO.INTEGRITY)
          success=0
          for i in {1..10}; do
            echo "Attempt $i to check integrity..."
            integrity_content=$(curl -L -s "$integrity_url")
            echo "base url: $base_url"
            echo "token: $token"
            echo "iurl: $integrity_url"
            echo "ic: $integrity_content"
            echo "ifc: $integrity_file_content"
            if [[ "$integrity_content" == "$integrity_file_content" ]]; then
              success=1
              break
            fi
            sleep 7
          done
          if [[ "$success" -eq 0 ]]; then
            echo "Error: Integrity check failed for application after 10 attempts."
            stop_bbpro
            sleep 10
            exit 1
          fi

      # Print ngrok URL
      - name: Print ngrok URL
        run: echo "The complete ngrok URL is ${{ steps.ngrok.outputs.url }}"

      # Keep alive
      - name: Keep alive
        run: |
          sleep 30

      # Final check
      - name: Final check
        run: |
          base_url=$(echo "${{ steps.ngrok.outputs.url }}" | grep -oE 'https?://[^/]+')
          token=$(echo "${{ steps.ngrok.outputs.url }}" | grep -oE 'token=[^&]+' | sed 's/token=//') 
          integrity_url="${base_url}/integrity?session_token=${token}"
          integrity_file_content=$(cat $HOME/BBPRO.INTEGRITY)
          success=0
          for i in {1..2}; do
            echo "Attempt $i to check integrity..."
            integrity_content=$(curl -L -s "$integrity_url")
            echo "base url: $base_url"
            echo "token: $token"
            echo "iurl: $integrity_url"
            echo "ic: $integrity_content"
            echo "ifc: $integrity_file_content"
            if [[ "$integrity_content" == "$integrity_file_content" ]]; then
              success=1
              break
            fi
            sleep 7
          done
          if [[ "$success" -eq 0 ]]; then
            echo "Error: Integrity check failed for application after 2 attempts."
            stop_bbpro
            sleep 10
            exit 1
          fi
          stop_bbpro
          sleep 10
          exit 0

      # Cleanup
      - name: Cleanup
        if: always()
        run: |
          stop_bbpro || true
          sleep 5
