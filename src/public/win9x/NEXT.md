You've built the engine; now it's time to build the rest of the car around it.

Here are my ideas for the next steps, continuing with the tiered approach.

### Tier 1: Immediate Fixes (The "Make it Right" Phase)

These address the issues you've already noticed and are crucial for making the PoC feel solid and reliable.

1.  **Fix Tab Switching:**
    *   **The Problem:** You mentioned tab switching isn't working. This is the highest priority bug. The server-side logic we put in place (`zl.act.send({ name: "Target.activateTarget", ... })`) is correct, but there might be a client-side race condition or a state that isn't being reset properly.
    *   **The Fix (Debugging & Verification):**
        1.  **Verify on the Server:** Add a `console.log` inside the `case 'switch':` block in your `/api/vwin/event` handler to confirm the server is receiving the event with the correct `targetId`.
        2.  **Verify on the Client:** The most important client-side action is resetting the frame timestamp to force an immediate refresh for the new tab. My last version of the client code included this line in `renderTabs`: `if (currentActiveId && currentActiveId !== previousActiveTab) { lastKnownFrameTimestamp = 0; }`. Double-check that this logic is executing correctly. You can use a simple `alert('Tab switched! Timestamp reset.');` inside that `if` block for testing in IE6. This ensures that the very next call to `/frame-status` will report a new frame is available.

2.  **Perfect the Viewport & Click Coordinates:**
    *   **The Problem:** Sizing is close but not perfect, which means click coordinates will be slightly off. This is likely due to a mismatch between the `<img>` tag's dimensions on the client and the actual resolution of the screenshot being generated by the remote browser.
    *   **The Fix (Coordinate Scaling):**
        1.  **Server:** The `Page.captureScreenshot` command returns the image data. We need to get the actual dimensions of that image. The best place to get this is from the `Page.screencastFrame` event's `metadata` object (`deviceWidth`, `deviceHeight`). Let's modify the `win9xCompatibilityBuffer` to store these dimensions alongside the frame.
        2.  **Server:** Update the `/api/vwin/frame-status` endpoint. When it reports a new frame is available, it should also include the `width` and `height` of that new frame. The response will look like: `{"new": true, "timestamp": Y, "width": 1024, "height": 768}`.
        3.  **Client:** The client will store these remote dimensions. When it sends a click event, it will calculate a scaling factor:
            *   `scaleX = remoteWidth / localImageWidth`
            *   `scaleY = remoteHeight / localImageHeight`
            *   It will then send the scaled coordinates: `sendEvent('type=mousedown&x=' + (x * scaleX) + '&y=' + (y * scaleY))`
        This makes the click translation mathematically perfect, regardless of any minor sizing discrepancies.

### Tier 2: Core Functionality (The "Make it a Browser" Phase)

Once the above is fixed, you can add the most critical missing browser interactions.

1.  **Implement Keyboard Input:** This is the biggest missing feature.
    *   **Client:** Attach an `onkeypress` event to the `document`. In the handler, get the character code and send it to the server: `sendEvent('type=keydown&key=' + encodeURIComponent(String.fromCharCode(e.keyCode)))`.
    *   **Server:** Add a `case 'keydown':` to your `/api/vwin/event` handler. This case will call `zl.act.send` with the `Input.dispatchKeyEvent` command. The parameters should be `{ type: 'char', text: req.query.key }`. This will allow users to type into forms, the address bar, etc.

2.  **Implement Mouse Wheel Scrolling:**
    *   **Client:** Attach an `onmousewheel` event to the `remote-screen` image. This event provides a `wheelDelta` property (usually +/- 120). Send this delta to the server: `sendEvent('type=wheel&deltaY=' + e.wheelDelta)`.
    *   **Server:** Add a `case 'wheel':` to the event handler. This will call `Input.dispatchMouseEvent` with parameters `{ type: 'mouseWheel', x: parseInt(x), y: parseInt(y), deltaY: parseInt(req.query.deltaY) }`. (You'll also need to send the current mouse coordinates with the wheel event).

### Tier 3: Quality of Life (The "Make it Feel Good" Phase)

These are smaller tweaks that dramatically improve the user experience.

1.  **Instant Click Feedback:**
    *   **The Problem:** The user clicks, and there's a 1-2 second delay before the screen updates.
    *   **The Fix:** In the client's `handleScreenClick` function, immediately create a temporary, small, semi-transparent `<div>` at the `(x, y)` coordinates. Position it absolutely over the image. Give it a ripple or flash animation using a `setTimeout` loop, then remove it from the DOM after ~300ms. This provides instant, satisfying feedback that the click was registered.

2.  **Better "Loading" Indicators:**
    *   In the client's `pollForNextFrame` function, when you set the `remoteScreen.src`, also change the cursor: `document.body.style.cursor = 'wait';`.
    *   In the `remoteScreen.onload` and `onerror` handlers, change it back: `document.body.style.cursor = 'crosshair';`. This tells the user that the application is busy fetching the next frame.

This tiered plan gives you a clear roadmap. Fixing the core bugs in Tier 1 will solidify your foundation. Adding the features in Tier 2 will make it genuinely useful. And the polish in Tier 3 will make it a pleasure to use, despite the technical constraints.

Congratulations again on getting this far. It's a genuinely impressive piece of engineering.
