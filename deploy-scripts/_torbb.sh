#!/usr/bin/env bash

# Debug
if [[ -n "${BBX_DEBUG}" ]]; then
  set -x
fi
set -euo pipefail

# -----------------------------
# Global Variables / Defaults
# -----------------------------
OS_TYPE=""
TOR_INSTALLED=false
SUDO=""
TORRC=""
TORDIR=""
TOR_USER=""
TOR_GROUP=""
TOR_SERVICE="tor@default"  # Linux instance-based setups
torsslcerts="tor-sslcerts"
COOKIE_AUTH_FILE=""

if command -v sudo &>/dev/null; then
  SUDO="sudo -n"
fi

# Make sure our log dir/file exist so later 'tail' doesn't fail
mkdir -p "${HOME}/.config/dosyago/bbpro"
: > "${HOME}/.config/dosyago/bbpro/torbb_errors.txt" || true


# -----------------------------
# OS Detection & Paths
# -----------------------------
detect_os() {
  if [[ "$OSTYPE" == "darwin"* ]]; then
    OS_TYPE="macos"
    TOR_USER="$USER"
    TOR_GROUP="staff"   # Homebrew uses your login user; group 'staff' is safe default

    # Use the main Homebrew prefix for etc/ and var/
    local bprefix
    bprefix="$(brew --prefix 2>/dev/null || echo "/opt/homebrew")"

    TORRC="${bprefix}/etc/tor/torrc"
    TORDIR="${bprefix}/var/lib/tor"

    # Ensure directories exist
    mkdir -p "${bprefix}/etc/tor" "${TORDIR}"

    # If torrc is missing, try to copy sample; else create a minimal one
    if [[ ! -f "$TORRC" ]]; then
      if [[ -f "${bprefix}/etc/tor/torrc.sample" ]]; then
        cp "${bprefix}/etc/tor/torrc.sample" "$TORRC"
      else
        cat >"$TORRC" <<'MINITORRC'
# Minimal torrc generated by setup
DataDirectory __TORDIR__
ControlPort 9051
CookieAuthentication 1
# Avoid pidfile permission surprises under brew services
AvoidDiskWrites 1
MINITORRC
        # Fill in TORDIR
        sed -i '' -e "s#__TORDIR__#${TORDIR}#g" "$TORRC" 2>/dev/null || \
        sed -i -e "s#__TORDIR__#${TORDIR}#g" "$TORRC"
      fi
    fi

    COOKIE_AUTH_FILE="${TORDIR}/control_auth_cookie"
  elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
    if [ -f /etc/debian_version ]; then
      OS_TYPE="debian"; TOR_USER="debian-tor"; TOR_GROUP="debian-tor"
    elif [ -f /etc/centos-release ] || [ -f /etc/redhat-release ]; then
      OS_TYPE="centos"; TOR_USER="toranon"; TOR_GROUP="toranon"
    elif [ -f /etc/arch-release ]; then
      OS_TYPE="arch"; TOR_USER="tor"; TOR_GROUP="tor"
    elif [ -f /etc/amazon-linux-release ]; then
      OS_TYPE="centos"; TOR_USER="toranon"; TOR_GROUP="toranon"
    else
      echo "Unsupported Linux distribution" >&2; exit 1
    fi
    TORRC="/etc/tor/torrc"; TORDIR="/var/lib/tor"
  elif [[ "$OSTYPE" == "MINGW"* || "$OSTYPE" == "MSYS"* || "$OSTYPE" == "cygwin"* ]]; then
    OS_TYPE="win"; TOR_USER="$USER"; TOR_GROUP=""
    TORRC="$HOME/tor/torrc"; TORDIR="$HOME/tor/data"
  else
    echo "Unsupported OS" >&2; exit 1
  fi
  COOKIE_AUTH_FILE="$TORDIR/control_auth_cookie"
}

find_torrc_path() {
  if [[ "$OS_TYPE" == "macos" ]]; then
    local bprefix
    bprefix="$(brew --prefix 2>/dev/null || echo "/opt/homebrew")"
    TORRC="${bprefix}/etc/tor/torrc"
    TORDIR="${bprefix}/var/lib/tor"
    mkdir -p "${bprefix}/etc/tor" "${TORDIR}"

    if [[ ! -f "$TORRC" ]]; then
      if [[ -f "${bprefix}/etc/tor/torrc.sample" ]]; then
        cp "${bprefix}/etc/tor/torrc.sample" "$TORRC"
      else
        cat >"$TORRC" <<'MINITORRC'
DataDirectory __TORDIR__
ControlPort 9051
CookieAuthentication 1
AvoidDiskWrites 1
MINITORRC
        sed -i '' -e "s#__TORDIR__#${TORDIR}#g" "$TORRC" 2>/dev/null || \
        sed -i -e "s#__TORDIR__#${TORDIR}#g" "$TORRC"
      fi
    fi
  elif [[ "$OS_TYPE" == "win" ]]; then
    TORRC="${HOME}/tor/torrc"; TORDIR="${HOME}/tor/data"
    mkdir -p "$TORDIR"; [[ -f "$TORRC" ]] || touch "$TORRC"
  else
    TORRC="/etc/tor/torrc"; TORDIR="/var/lib/tor"
  fi
  COOKIE_AUTH_FILE="${TORDIR}/control_auth_cookie"
  echo "$TORRC"
}

# -----------------------------
# Group check (Linux only)
# -----------------------------
check_tor_group() {
  if [[ "$OS_TYPE" == "macos" || "$OS_TYPE" == "win" ]]; then
    echo "No group check needed for $OS_TYPE" >&2
  elif id -nG "$USER" | grep -qw "$TOR_GROUP"; then
    echo "User $USER is in the correct Tor group ($TOR_GROUP)." >&2
  else
    echo "Error: User $USER is not in the $TOR_GROUP group." >&2
    echo "Please run 'sudo setup_tor $USER' to configure Tor for this user." >&2
    exit 1
  fi
}

# -----------------------------
# Package Manager
# -----------------------------
initialize_package_manager() {
  local package_manager
  if [[ "$OS_TYPE" == "macos" ]]; then
    package_manager=$(command -v brew)
  elif [[ "$OS_TYPE" == "win" ]]; then
    package_manager=$(command -v choco || command -v scoop)
  elif command -v apt &>/dev/null; then
    package_manager=$(command -v apt)
    if command -v apt-get &>/dev/null; then
      source non-interactive.sh >&2 || true
    fi
  elif command -v dnf >/dev/null 2>&1; then
    package_manager="$(command -v dnf) --best --allowerasing --skip-broken"
  elif command -v pacman >/dev/null 2>&1; then
    package_manager=$(command -v pacman)
  else
    echo "No supported package manager found. Exiting." >&2
    return 1
  fi
  echo "Using package manager: $package_manager" >&2
  export APT=$package_manager
}

# -----------------------------
# Utilities
# -----------------------------
ensure_shutdown() { pm2 delete all >/dev/null 2>&1 || true; }
os_type() {
  case "$(uname -s)" in
    Darwin*) echo "macOS";;
    Linux*)  echo "Linux";;
    MING*|MSYS*|CYGWIN*) echo "win";;
    *)       echo "unknown";;
  esac
}

find_mkcert_root_ca() {
  local mkcert_dir=""
  mkcert_dir="$(mkcert -CAROOT 2>/dev/null || true)"
  if [[ -n "$mkcert_dir" ]]; then echo "$mkcert_dir"; return 0; fi
  case "$(uname)" in
    "Linux") mkcert_dir="${HOME}/.local/share/mkcert";;
    "Darwin") mkcert_dir="${HOME}/Library/Application Support/mkcert";;
    "MINGW"*|"MSYS"*|"CYGWIN"*) mkcert_dir="${HOME}/AppData/Local/mkcert";;
    *) echo "Unsupported OS for mkcert root ca location finding" >&2; return 1;;
  esac
  if [ -d "$mkcert_dir" ]; then echo "$mkcert_dir"; else echo "warning: mkcert directory not found." >&2; return 1; fi
}

get_normalized_arch() {
  local arch
  arch="$(dpkg --print-architecture 2>/dev/null || uname -m)"
  if [ "$arch" = "x86_64" ] || [ "$arch" = "amd64" ]; then echo "amd64"; else echo "$arch"; fi
}

setup_mkcert() {
  echo "Setting up mkcert..." >&2
  if ! command -v mkcert &>/dev/null; then
    if [ "$OS_TYPE" == "macos" ]; then
      brew install nss mkcert
    elif [ "$OS_TYPE" == "win" ]; then
      choco install mkcert || { scoop bucket add extras && scoop install mkcert; }
    else
      local amd64; amd64="$(get_normalized_arch)"
      if [[ "$OS_TYPE" == "centos" ]]; then
        $SUDO $APT install -y nss-tools
      elif [[ "$OS_TYPE" == "debian" || "$OS_TYPE" == "arch" ]]; then
        $SUDO $APT install -y libnss3-tools
      fi
      curl -fsSL -o mkcert "https://dl.filippo.io/mkcert/latest?for=linux/${amd64}"
      chmod +x mkcert
      $SUDO mv mkcert /usr/local/bin/mkcert
    fi
    mkcert -install
  fi
}

# -----------------------------
# Tor Installation
# -----------------------------
install_tor() {
  if command -v tor &>/dev/null; then
    TOR_INSTALLED=true; echo "Tor is installed" >&2; return
  fi
  case $OS_TYPE in
    debian)
      echo "Adding Tor repository for Debian..." >&2
      $SUDO apt-get update
      $SUDO apt-get install -y apt-transport-https gpg wget
      wget -qO- https://deb.torproject.org/torproject.org/A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89.asc | gpg --import
      gpg --export A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89 | $SUDO apt-key add -
      echo "deb https://deb.torproject.org/torproject.org $(lsb_release -sc) main" | $SUDO tee /etc/apt/sources.list.d/tor.list
      $SUDO apt-get update
      $SUDO apt-get install -y tor deb.torproject.org-keyring
      TOR_INSTALLED=true
      ;;
    centos)
      $SUDO yum install -y epel-release || $SUDO dnf install -y epel-release
      $SUDO yum install -y tor || $SUDO dnf install -y tor
      TOR_INSTALLED=true
      ;;
    arch)
      $SUDO pacman -Sy --noconfirm tor
      TOR_INSTALLED=true
      ;;
    macos)
      brew install tor
      TOR_INSTALLED=true
      ;;
    win)
      echo "Please install Tor manually on Windows: https://www.torproject.org/download/" >&2
      exit 1
      ;;
  esac
}

# -----------------------------
# Netcat helpers (timeout/EOF)
# -----------------------------
_nc_detect() {
  local _nc; _nc="$(command -v nc || true)"
  [[ -z "$_nc" ]] && return 1
  echo "$_nc"
}
_nc_build_args() {
  local secs="${1:-5}"
  local _nc_help; _nc_help="$("$(_nc_detect)" -h 2>&1 || true)"
  local _eof=""; local _timeflag=(); local _timeout=""
  if grep -qE "(^|[[:space:]-])-N([[:space:]]|,|$)" <<<"$_nc_help"; then _eof="-N"; fi
  if grep -q -- "-q" <<<"$_nc_help"; then _eof="-q 0"; fi
  if command -v timeout >/dev/null 2>&1; then _timeout="timeout ${secs}"
  elif command -v gtimeout >/dev/null 2>&1; then _timeout="gtimeout ${secs}"
  elif grep -q -- "-w" <<<"$_nc_help"; then _timeflag=( -w "${secs}" ); fi
  # print as: timeout_cmd|||eof|||timeflag_csv
  echo "${_timeout}|||${_eof}|||${_timeflag[*]}"
}

# -----------------------------
# macOS Tor control helpers
# -----------------------------
macos_tor_control_probe() {
  local port="$1"
  local _nc="$(_nc_detect)" || return 1
  IFS='|' read -r _to _eof _tf <<<"$(_nc_build_args 2 | sed 's/|||/|/g')"
  local _timeflag=(); [[ -n "${_tf}" ]] && IFS=' ' read -r -a _timeflag <<<"$_tf"
  printf 'PROTOCOLINFO\r\nQUIT\r\n' | ${_to} "$_nc" "${_timeflag[@]}" ${_eof} 127.0.0.1 "$port" >/dev/null 2>&1
}

macos_pick_control_port_and_cookie() {
  local ports=()
  local conf_port
  conf_port="$(awk 'BEGIN{IGNORECASE=1} /^ControlPort[[:space:]]+/ {print $2; exit}' "$TORRC" 2>/dev/null || true)"
  [[ -n "$conf_port" ]] && ports+=("$conf_port")
  ports+=("9051" "9151")
  for p in "${ports[@]}"; do
    if macos_tor_control_probe "$p"; then
      local cookie="$TORDIR/control_auth_cookie"
      if [[ ! -f "$cookie" ]]; then
        local tb_cookie="${HOME}/Library/Application Support/TorBrowser-Data/Tor/control_auth_cookie"
        [[ -f "$tb_cookie" ]] && cookie="$tb_cookie"
      fi
      if [[ -f "$cookie" ]]; then
        echo "$p|$cookie"; return 0
      fi
    fi
  done
  return 1
}

torctl_auth_send() {
  local port="$1"; local cookie_file="$2"; shift 2
  local cmd="$*"
  local _nc="$(_nc_detect)" || { echo "nc missing" >&2; return 1; }
  IFS='|' read -r _to _eof _tf <<<"$(_nc_build_args 5 | sed 's/|||/|/g')"
  local _timeflag=(); [[ -n "${_tf}" ]] && IFS=' ' read -r -a _timeflag <<<"$_tf"
  local cookie_hex; cookie_hex="$(xxd -p "$cookie_file" 2>/dev/null | tr -d '\n')"
  [[ -z "$cookie_hex" ]] && { echo "empty cookie" >&2; return 1; }
  local payload; payload=$(printf 'AUTHENTICATE %s\r\n%s\r\nQUIT\r\n' "$cookie_hex" "$cmd")
  printf '%s' "$payload" | ${_to} "$_nc" "${_timeflag[@]}" ${_eof} 127.0.0.1 "$port"
}

# -----------------------------
# Control-port hidden service (Linux path, improved nc)
# -----------------------------
add_hidden_service_via_control_port() {
  local service_port="$1"
  local tor_control_port=9051
  local tor_cookie_file="$COOKIE_AUTH_FILE"
  if ! $SUDO test -f "$tor_cookie_file" && [[ -f "${HOME}/.tor/control_auth_cookie" ]]; then
    tor_cookie_file="${HOME}/.tor/control_auth_cookie"
  fi
  local tor_cookie_hex=""
  if [[ "$OS_TYPE" == "macos" || "$OS_TYPE" == "win" ]]; then
    tor_cookie_hex=$(xxd -u -p "$tor_cookie_file" 2>/dev/null | tr -d '\n')
  else
    tor_cookie_hex=$($SUDO xxd -u -p "$tor_cookie_file" 2>/dev/null | tr -d '\n')
  fi
  if [[ -z "$tor_cookie_hex" ]]; then
    echo "Failed to read Tor control cookie from $tor_cookie_file" >&2; exit 1
  fi
  local control_command; control_command=$(printf 'AUTHENTICATE %s\r\nADD_ONION NEW:ED25519-V3 Flags=Detach Port=443,127.0.0.1:%s\r\nQUIT\r\n' "$tor_cookie_hex" "$service_port")
  local _nc="$(_nc_detect)" || { echo "nc missing" >&2; exit 1; }
  IFS='|' read -r _to _eof _tf <<<"$(_nc_build_args 5 | sed 's/|||/|/g')"
  local _timeflag=(); [[ -n "${_tf}" ]] && IFS=' ' read -r -a _timeflag <<<"$_tf"
  local response; response=$(printf '%s' "$control_command" | ${_to} "$_nc" "${_timeflag[@]}" ${_eof} 127.0.0.1 "$tor_control_port" || true)
  echo "Got Tor response: $response" >&2
  local onion_address; onion_address=$(echo "$response" | grep '^250-ServiceID=' | cut -d'=' -f2 | tr -d '[:space:]')
  if [[ -z "$onion_address" ]]; then
    echo "Failed to obtain Onion address for port $service_port." >&2
    exit 1
  fi
  echo "${onion_address}.onion"
}

# -----------------------------
# Wait for hostname files
# -----------------------------
wait_for_hostnames() {
  local base_port=$((APP_PORT - 2))
  local all_exist=0
  while [ $all_exist -eq 0 ]; do
    all_exist=1
    for i in {0..4}; do
      local service_port=$((base_port + i))
      local hidden_service_dir="${TORDIR}/hidden_service_${service_port}"
      if [[ "$OS_TYPE" == "macos" || "$OS_TYPE" == "win" ]]; then
        [ -f "${hidden_service_dir}/hostname" ] || $SUDO test -f "${hidden_service_dir}/hostname" || all_exist=0
      else
        $SUDO test -f "${hidden_service_dir}/hostname" || all_exist=0
      fi
    done
    [ $all_exist -eq 0 ] && sleep 1
  done
}

# -----------------------------
# Configure Tor (macOS live-reload)
# -----------------------------
configure_and_export_tor() {
  local base_port=$((APP_PORT - 2))
  echo "Setting up tor hidden services..." >&2

  # Ensure HS blocks exist and directories are secure
  for i in {0..4}; do
    local service_port=$((base_port + i))
    local hidden_service_dir="${TORDIR}/hidden_service_${service_port}"
    local dirLine="HiddenServiceDir ${hidden_service_dir}"
    if ! grep -qF -- "$dirLine" "$TORRC"; then
      echo "$dirLine" | $SUDO tee -a "$TORRC" >/dev/null
      echo "HiddenServicePort 443 127.0.0.1:${service_port}" | $SUDO tee -a "$TORRC" >/dev/null
    fi
    $SUDO mkdir -p "$hidden_service_dir"
    if [[ "$OS_TYPE" == "macos" ]]; then
      $SUDO chown "$USER:staff" "$hidden_service_dir" 2>/dev/null || true
      $SUDO chmod 700 "$hidden_service_dir"
    else
      $SUDO chown "${TOR_USER}:${TOR_GROUP}" "$hidden_service_dir"
      $SUDO chmod 770 "$hidden_service_dir"
    fi
  done

  if [[ "$OS_TYPE" == "macos" ]]; then
    # Try to attach and live-reload first
    local pick; pick="$(macos_pick_control_port_and_cookie || true)"
    if [[ -n "$pick" ]]; then
      local ctrl_port="${pick%%|*}"
      local cookie_file="${pick##*|}"
      echo "macOS: Found control port ${ctrl_port}; attempting SIGNAL RELOAD..." >&2
      if torctl_auth_send "$ctrl_port" "$cookie_file" "SIGNAL RELOAD" >/dev/null 2>&1; then
        echo "Tor config reloaded without restart." >&2
      else
        echo "Reload failed; restarting Homebrew tor service..." >&2
        brew services restart tor >/dev/null 2>&1 || true
        sleep 2
        if ! macos_tor_control_probe "${ctrl_port}"; then
          pkill -x tor 2>/dev/null || true
          nohup tor -f "$TORRC" >/dev/null 2>&1 &
          sleep 2
        fi
      fi
    else
      echo "macOS: No healthy control port; (re)starting Homebrew tor..." >&2
      brew services restart tor >/dev/null 2>&1 || brew services start tor >/dev/null 2>&1 || true
      sleep 2
      if ! macos_tor_control_probe "9051" && ! macos_tor_control_probe "9151"; then
        pkill -x tor 2>/dev/null || true
        nohup tor -f "$TORRC" >/dev/null 2>&1 &
        sleep 2
      fi
    fi
  else
    echo "Restarting tor..." >&2
    $SUDO systemctl restart "$TOR_SERVICE" &>/dev/null || true
    if [[ -f /.dockerenv ]] || ! systemctl is-active "$TOR_SERVICE" >/devnull 2>&1; then
      echo "Detected Docker or systemd failure, starting Tor manually..." >&2
      $SUDO pkill -x tor 2>/dev/null || true
      if [[ "$OS_TYPE" == "centos" ]]; then
        $SUDO -u "$TOR_GROUP" nohup tor -f "$TORRC" >/dev/null 2>&1 &
      elif [[ "$OS_TYPE" == "debian" || "$OS_TYPE" == "arch" ]]; then
        $SUDO nohup tor -f "$TORRC" >/dev/null 2>&1 &
      fi
      sleep 2
      if ! pgrep -f tor >/dev/null; then
        echo "Failed to start Tor manually" >&2; exit 1
      fi
    fi
  fi

  echo "Waiting for onion services to connect..." >&2
  wait_for_hostnames

  echo "Creating HTTPS TLS certs for onion domains..." >&2
  setup_mkcert
  for i in {0..4}; do
    local service_port=$((base_port + i))
    local hidden_service_dir="$TORDIR/hidden_service_${service_port}"
    local onion_address
    if [[ "$OS_TYPE" == "macos" || "$OS_TYPE" == "win" ]]; then
      onion_address="$(cat "${hidden_service_dir}/hostname")"
    else
      onion_address="$($SUDO cat "${hidden_service_dir}/hostname")"
    fi
    export "ADDR_${service_port}=${onion_address}"
    echo "$service_port $onion_address" >&2
    local cert_dir="$HOME/${torsslcerts}/${onion_address}"
    mkdir -p "$cert_dir"
    if ! mkcert -cert-file "${cert_dir}/fullchain.pem" -key-file "${cert_dir}/privkey.pem" "$onion_address" >/dev/null 2>&1; then
      echo "mkcert failed for $onion_address" >&2; exit 1
    fi
  done
}

# -----------------------------
# Firewall helper
# -----------------------------
get_ssh_port() {
  local ssh_port; ssh_port=$(grep -i '^Port ' /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')
  [[ -z "$ssh_port" ]] && ssh_port=22
  echo "$ssh_port"
}

manage_firewall() {
  echo "Closing firewall (except ssh)..." >&2
  case $OS_TYPE in
    debian|centos|arch)
      $SUDO ufw allow "$(get_ssh_port)" &>/dev/null || true
      $SUDO ufw --force enable &>/dev/null || true
      ;;
    macos)
      echo "Warning: Please ensure your firewall is enabled in macOS Settings." >&2
      ;;
    win)
      echo "Warning: Configure Windows Firewall manually to allow SSH and Tor." >&2
      ;;
  esac
}

# -----------------------------
# Main
# -----------------------------
{
  if command -v bbpro >/dev/null 2>&1; then
    echo "bbpro installed. proceeding..." >&2
  else
    echo "bbpro not installed. please run" >&2
    echo "./deploy-scripts/global_install.sh localhost" >&2
    echo "before proceeding." >&2
    exit 1
  fi

  detect_os
  check_tor_group
  initialize_package_manager
  if command -v tor &>/dev/null; then TOR_INSTALLED=true; else install_tor; fi

  if [[ "$OS_TYPE" == "macos" ]]; then
    # Ensure DataDirectory is correct
    if ! grep -qiE "^DataDirectory[[:space:]]+${TORDIR}$" "$TORRC"; then
      # Replace existing DataDirectory or append if missing
      if grep -qiE "^DataDirectory[[:space:]]+" "$TORRC"; then
        # macOS sed needs backup suffix or empty string
        sed -i '' -e "s#^DataDirectory[[:space:]].*#DataDirectory ${TORDIR}#I" "$TORRC" 2>/dev/null || \
        sed -i -e "s#^DataDirectory[[:space:]].*#DataDirectory ${TORDIR}#I" "$TORRC"
      else
        printf '\nDataDirectory %s\n' "$TORDIR" >> "$TORRC"
      fi
    fi
  fi

  # bb env
  source ~/.config/dosyago/bbpro/test.env || { echo "bb environment not found. please run setup_bbpro first." >&2; exit 1; }
  [ -z "${CONFIG_DIR:-}" ] && { echo "CONFIG_DIR not set. Run setup_bbpro again." >&2; exit 1; }
  [[ ${APP_PORT:-} =~ ^[0-9]+$ ]] || { echo "Invalid APP_PORT" >&2; exit 1; }

  # Optional repo config
  CONFIG_FILE="${CONFIG_DIR}/config"
  if [[ -f "$CONFIG_FILE" ]]; then
    echo "Sourcing $CONFIG_FILE..." >&2
    # shellcheck disable=SC1090
    source "$CONFIG_FILE"
  else
    echo "No config file found at ${CONFIG_FILE}. Proceeding without it." >&2
  fi

  # LICENSE_KEY prompt (unchanged)
  if [[ -z "${LICENSE_KEY:-}" ]]; then
    echo "LICENSE_KEY is required to proceed." >&2
    while [[ -z "${LICENSE_KEY:-}" ]]; do
      read -p "Please enter your LICENSE_KEY: " LICENSE_KEY
      if [[ -z "$LICENSE_KEY" ]]; then echo "ERROR: LICENSE_KEY cannot be empty. Please try again." >&2; fi
    done
    echo "LICENSE_KEY set." >&2
  else
    echo "LICENSE_KEY is already set." >&2
  fi

  echo "Ensuring any other bbpro $USER was running is shutdown..." >&2
  ensure_shutdown

  find_torrc_path

  if [[ "$OS_TYPE" == "macos" || "$OS_TYPE" == "win" ]]; then
    [[ $TOR_INSTALLED == true ]] && configure_and_export_tor
    manage_firewall
  else
    manage_firewall
    base_port=$((APP_PORT - 2))
    echo "Setting up tor hidden services via Control Port..." >&2
    for i in {0..4}; do
      service_port=$((base_port + i))
      onion_address="$(add_hidden_service_via_control_port "$service_port")"
      export "ADDR_${service_port}=${onion_address}"
      echo "Onion address for port ${service_port}: ${onion_address}" >&2
      cert_dir="$HOME/${torsslcerts}/${onion_address}"
      setup_mkcert
      mkdir -p "$cert_dir"
      if ! mkcert -cert-file "${cert_dir}/fullchain.pem" -key-file "${cert_dir}/privkey.pem" "$onion_address" >/dev/null 2>&1; then
        echo "mkcert failed for $onion_address" >&2; exit 1
      fi
    done
  fi

  cert_root=$(find_mkcert_root_ca || true)

  cat > "${CONFIG_DIR}/torbb.env" <<EOF
source "${CONFIG_DIR}/test.env"
export TORBB=true
export TORCA_CERT_ROOT="${cert_root}"
export SSLCERTS_DIR="${torsslcerts}"
EOF
  base_port=$((APP_PORT - 2))
  for i in {0..4}; do
    service_port=$((base_port + i))
    ref="ADDR_${service_port}"
    echo "export ${ref}=${!ref}" >> "${CONFIG_DIR}/torbb.env"
  done

  export TORBB=true
  echo -n "Starting bbpro..." >&2
  if ! bbpro &>/dev/null; then
    echo "bbpro failed to start..." >&2; exit 1
  fi
  echo "Started!" >&2
} >&2

# Final output
ref="ADDR_${APP_PORT}"
cert_file="${HOME}/${torsslcerts}/${!ref}/fullchain.pem"
DOMAIN="${!ref}"
LOGIN_LINK="https://${DOMAIN}/login?token=${LOGIN_TOKEN}"
echo "$LOGIN_LINK" > "${CONFIG_DIR}/login.link"
echo "Login link for Tor hidden service BB instance:" >&2
echo "$LOGIN_LINK"

